"""
Custom App Inventory Transformer

This module provides functionality to transform CSV inventory files into
a standardized JSON format for custom applications.
"""

import argparse
import logging
import csv
import datetime
import json
import traceback
from dataclasses import asdict, dataclass, field
from typing import Dict, List, Optional, Generator, Tuple, Any
from pathlib import Path
from enum import Enum


# Configure logging
logger = logging.getLogger(__name__)

# Constants
DEFAULT_BATCH_SIZE = 100
DEFAULT_OUTPUT_DIR = "/tmp/customapp_export"
DEFAULT_APP_NAME = "custom_app_sample"


class UserStatus(Enum):
    """Represents a user status in the custom application inventory."""
    ENABLED = "ENABLED"
    DEACTIVATED = "DEACTIVATED"

class PrincipalType(Enum):
    """Represents a principal type in the custom application inventory."""
    HUMAN = "HUMAN"
    NHI = "NHI"
    GROUP = "GROUP"

class RoleType(Enum):
    """Represents a role type in the custom application inventory."""
    CUSTOM_APP_ROLE = "CUSTOM_APP_ROLE"
    CUSTOM_APP_USER_ROLE = "CUSTOM_APP_USER_ROLE"

class PermissionAccessLevel(Enum):
    """Represents a permission access level in the custom application inventory."""
    READ = "READ"
    WRITE = "WRITE"


@dataclass
class CustomAppUser:
    """Represents a user in the custom application inventory."""
    username: str
    name: str
    # if not provided, it will be generated by the transformer based on the username
    id: str
    status: Optional[str] = UserStatus.ENABLED.name


@dataclass
class CustomAppRole:
    """Represents a role in the custom application inventory."""
    name: str
    id: str
    type: Optional[str] = RoleType.CUSTOM_APP_ROLE.name
    # names of the permissions assigned to the role
    permissions: List[str] = field(default_factory=list)


@dataclass
class CustomAppRoleAssignment:
    """Represents a role assignment in the custom application inventory."""
    id: str
    principalId: str  # user, NHI, or group ID  # noqa: E501
    principalType: str  # noqa: E501
    roleId: str  # noqa: E501
    scopeId: Optional[str] = None  # noqa: E501

@dataclass
class CustomAppPermission:
    """Represents a permission in the custom application inventory."""
    name: str
    accessLevel: Optional[str] = None # e.g., "READ", "WRITE"  # noqa: E501
    serviceName: Optional[str] = None  # noqa: E501
    # noqa: E501


@dataclass
class CustomAppInventory:
    """Container for all custom application inventory data."""
    users: Dict[str, CustomAppUser] = field(default_factory=dict)
    roles: Dict[str, CustomAppRole] = field(default_factory=dict)
    assignments: Dict[str, CustomAppRoleAssignment] = field(default_factory=dict)
    permissions: Dict[str, CustomAppPermission] = field(default_factory=dict)


class CustomAppInventoryType1Transformer:
    """
    Abstract class for custom app type1 inventory transformer.
    Implements all the common helper methods different custom apps
    """
    def __init__(self, app_name: str, inventory_file: str,
                 output_dir: str):
        self.app_name = app_name
        self.inventory_file = inventory_file
        self.inventory_type = 'CUSTOM_TYPE1_INVENTORY_CSV'
        self.output_dir = output_dir
        self.inventory = CustomAppInventory()

    def convert_to_andromeda_dict(self, obj: Any) -> Any:
        """
        Recursively convert dictionary keys from snake_case to camelCase.
        And removes empty values.
        Handles dictionaries, lists, and nested structures.
        Args:
            obj: Any object (dict, list, or primitive type)
        Returns:
            Object with snake_case keys converted to camelCase
        """
        if isinstance(obj, str):
            return obj
        if isinstance(obj, dict):
            # return key and values where value is not empty
            return {k:self.convert_to_andromeda_dict(v) for k, v in obj.items() if v}
        if isinstance(obj, list):
            return [self.convert_to_andromeda_dict(item) for item in obj if item]
        return obj

    def convert_snake_to_camel(self, snake_str: str) -> str:
        """Convert snake_case string to camelCase."""
        parts = snake_str.split('_')
        return parts[0] + ''.join(word.capitalize() for word in parts[1:])

    def csv_batch_reader(self, csv_file: str, batch_size: int=100) -> Generator[list, None, None]:
        """ Read CSV file in batches """
        with open(csv_file, 'r', encoding="utf-8") as f:
            csv_reader = csv.DictReader(f)
            batch = []
            for row in csv_reader:
                batch.append(row)
                if len(batch) == batch_size:
                    yield batch
                    batch = []
            if batch:
                yield batch

    def transform(self) -> Tuple[CustomAppInventory, List[Dict[str, str]]]:
        """
        Transform the inventory csv into Andromeda Inventory and export it to a json file
        provided in the constructor
        Args:
        Returns:
        """
        raise NotImplementedError("Subclass must implement this method")

    def summarize(self) -> Dict[str, int]:
        """Generate summary statistics for inventory."""
        return {
            'users': len(self.inventory.users),
            'roles': len(self.inventory.roles),
            'assignments': len(self.inventory.assignments),
            'permissions': len(self.inventory.permissions)
        }

    def transform_and_export(self) -> CustomAppInventory:
        """
        Transform the inventory csv into Andromeda Inventory and export it to a json file
        provided in the constructor
        """
        _, errors = self.transform()
        if errors:
            logger.error("Ignored errors found in inventory file %s\n %s", len(errors), errors)
        # Create output directory if it doesn't exist
        Path(self.output_dir).mkdir(parents=True, exist_ok=True)

        # Generate output filename
        timestamp = datetime.datetime.now().replace(microsecond=0).isoformat()
        output_file = Path(f"{self.output_dir}/{self.app_name}-{timestamp}.json")

        # Log summary
        summary = self.summarize()
        logger.info("Summary of inventory file %s output to %s\n %s",
                    self.inventory_file, output_file, json.dumps(summary, indent=2))
        # Export to JSON
        try:
            # Convert to dictionary, camelize keys, and remove empty values
            #self.inventory_validation()
            inventory_dict = asdict(self.inventory)
            result_dict = self.convert_to_andromeda_dict(inventory_dict)
            with open(output_file, 'w', encoding="utf-8") as file:
                json.dump(result_dict, file, indent=2)
            return result_dict
        except Exception as e:
            logger.error("Error writing output file %s: %s", output_file, e)
            logger.error("Stack trace: %s", traceback.format_exc())
            raise

    def inventory_validation(self) -> None:
        """Validate the inventory."""
        self._validate_users()
        self._validate_roles()
        self._validate_assignments()

    def _validate_users(self) -> None:
        """Validate user data in the inventory."""
        for user in self.inventory.users.values():
            if user.status not in UserStatus:
                logger.error("User %s has invalid status %s", user, user.status)
                raise ValueError(f"User {user} has invalid status {user.status}")

    def _validate_roles(self) -> None:
        """Validate role data in the inventory."""
        for role in self.inventory.roles.values():
            if role.type not in RoleType:
                logger.error("Role %s has invalid type %s", role, role.type)
                raise ValueError(f"Role {role} has invalid type {role.type}")
            self._validate_role_permissions(role)

    def _validate_role_permissions(self, role: CustomAppRole) -> None:
        """Validate that role permissions exist in the inventory."""
        for permission in role.permissions:
            if permission not in self.inventory.permissions:
                logger.error("Role %s has permission %s that is not defined", role, permission)
                raise ValueError(f"Role {role} has permission {permission} that is not defined")

    def _validate_assignments(self) -> None:
        """Validate assignment data in the inventory."""
        for assignment in self.inventory.assignments.values():
            self._validate_assignment_fields(assignment)
            self._validate_assignment_principal_type(assignment)
            self._validate_assignment_references(assignment)

    def _validate_assignment_fields(self, assignment: CustomAppRoleAssignment) -> None:
        """Validate mandatory fields for an assignment."""
        mandatory_fields = ['principalId', 'roleId']
        for f in mandatory_fields:
            if not getattr(assignment, f):
                logger.error("Assignment %s has no %s", assignment, f)
                raise ValueError(f"Assignment {assignment} has no {f}")

    def _validate_assignment_principal_type(self, assignment: CustomAppRoleAssignment) -> None:
        """Validate that assignment principal type is valid."""
        if assignment.principalType not in PrincipalType:
            logger.error("Assignment %s has invalid principalType %s",
                         assignment, assignment.principalType)
            raise ValueError(f"Assignment {assignment.id} has invalid principalType {assignment.principalType}")

    def _validate_assignment_references(self, assignment: CustomAppRoleAssignment) -> None:
        """Validate that assignment references exist in the inventory."""
        # Validate principal exists if it's a human
        if (assignment.principalType == PrincipalType.HUMAN.name and
            assignment.principalId not in self.inventory.users):
            logger.error("Assignment %s has invalid principalId %s",
                         assignment, assignment.principalId)
            raise ValueError(f"Assignment {assignment} has invalid principalId {assignment.principalId}")
        # Validate role exists
        if assignment.roleId not in self.inventory.roles:
            logger.error("Assignment %s has invalid roleId %s",
                         assignment, assignment.roleId)
            raise ValueError(f"Assignment {assignment} has invalid roleId {assignment.roleId}")

# Example of a custom app transformer
class CustomAppSampleTransformer(CustomAppInventoryType1Transformer):
    """Transforms CSV inventory files into standardized JSON format."""
    NON_PERMISSIONS_KEYS = {
        'id', 'isActive', 'firstName', 'lastName', 'email', 'opRoleId',
        'employeeId', 'Manager', 'Department', 'total active dates',
        'createdDate', 'updatedDate', 'Total active permissions'
    }

    @staticmethod
    def create_user(row: Dict[str, str]) -> CustomAppUser:
        """Create a user object from CSV row data."""
        username = row['email']
        user_id = row.get('employeeId') or username
        full_name = f"{row.get('firstName', '')} {row.get('lastName', '')}".strip()
        status = UserStatus.ENABLED.name if row.get('isActive', '1') == '1' \
            else UserStatus.DEACTIVATED.name
        # if status is not provided, it will be generated by the transformer based on the username
        return CustomAppUser(
            id=user_id,
            username=username,
            name=full_name,
            status=status
        )

    @staticmethod
    def create_role(app_name_prefix: str, row: Dict[str, str]) -> Tuple[str, CustomAppRole]:
        """Create a role object from CSV row data."""
        role_name = row.get('opRoleId', '').strip()
        if not role_name:
            first_name = row.get('firstName', '').lower()
            last_name = row.get('lastName', '').lower()
            role_name = f"{app_name_prefix.lower()}-{first_name}-{last_name}-role"
            role_type = RoleType.CUSTOM_APP_USER_ROLE.name
        else:
            role_type = RoleType.CUSTOM_APP_ROLE.name

        permissions = [
            key for key, value in row.items()
            if key not in CustomAppSampleTransformer.NON_PERMISSIONS_KEYS and value == 'TRUE'
        ]

        role = CustomAppRole(
            id=role_name,
            name=role_name,
            type=role_type,
            permissions=permissions
        )

        return role_name, role

    @staticmethod
    def create_role_assignment(username: str, role_name: str) -> CustomAppRoleAssignment:
        """Create a role assignment object."""
        assignment_id = f"{username}_{role_name}"
        return CustomAppRoleAssignment(
            id=assignment_id,
            principalId=username,
            principalType=PrincipalType.HUMAN.name,
            roleId=role_name
        )

    @staticmethod
    def create_permission(permission_name: str) -> CustomAppPermission:
        """Create a permission object."""
        return CustomAppPermission(name=permission_name)


    @staticmethod
    def validate_user_data(row: Dict[str, str]) -> bool:
        """Validate user data from CSV row."""
        username = row.get('email', '').strip()
        if not username:
            logger.error("Skipping row: username not set in {%s}", row)
            return False
        return True

    @staticmethod
    def validate_role_permissions(role_name: str, existing_permissions: List[str],
                                  new_permissions: List[str]) -> bool:
        """Validate role permissions consistency."""
        if existing_permissions and set(new_permissions) != set(existing_permissions):
            logger.error("Role %s has conflicting permissions: %s", role_name,
                         set(new_permissions).difference(set(existing_permissions)))
            return False
        return True

    @staticmethod
    def validate_assignment_conflict(assignment_id: str) -> bool:
        """Validate no conflicting role assignments."""
        return True  # This will be checked in the main logic

    def _process_csv_row(self, inventory: CustomAppInventory, row: Dict[str, str],
                         errors: List[Dict[str, str]]) -> None:
        """Process a single CSV row and update inventory."""
        # Validate user data
        if not self.validate_user_data(row):
            errors.append(row)
            logger.error("Skipping row: %s as user data is not valid", row)
            return

        username = row['email']
        # Create or update user
        user = self.create_user(row)
        inventory.users[username] = user
        # Create or update role
        role_name, role = self.create_role(self.app_name, row)

        # Validate role permissions
        if role_name in inventory.roles:
            existing_role = inventory.roles[role_name]
            if not self.validate_role_permissions(
                role_name, existing_role.permissions, role.permissions):
                errors.append(row)
                return
            # Merge permissions
            existing_role.permissions.extend(role.permissions)
            role = existing_role

        inventory.roles[role_name] = role

        # Create role assignment
        assignment = self.create_role_assignment(username, role_name)

        # Check for assignment conflicts
        if assignment.id in inventory.assignments:
            logger.error("Skipping conflicting assignment: %s", assignment.id)
            errors.append(row)
            return

        inventory.assignments[assignment.id] = assignment

        # Create permissions
        for permission_name in role.permissions:
            if permission_name not in inventory.permissions:
                permission = self.create_permission(permission_name)
                inventory.permissions[permission_name] = permission

    def transform(self) -> Tuple[CustomAppInventory, List[Dict[str, str]]]:
        """Transform custom type 1 inventory CSV file."""
        errors = []
        try:
            for batch in self.csv_batch_reader(self.inventory_file):
                for row in batch:
                    self._process_csv_row(self.inventory, row, errors)
        except Exception as e:
            logger.error("Error processing inventory file %s: %s", self.inventory_file, e)
            raise

        return self.inventory, errors


def setup_logging() -> None:
    """Setup logging configuration."""
    logger.setLevel(logging.INFO)

    # Remove existing handlers to avoid duplicates
    for handler in logger.handlers[:]:
        logger.removeHandler(handler)

    # Create console handler
    console_handler = logging.StreamHandler()
    formatter = logging.Formatter(
        '%(asctime)s:%(levelname)s:%(module)s:%(funcName)s:%(lineno)s: %(message)s'
    )
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)


def parse_arguments() -> argparse.Namespace:
    """Setup arguments for the script."""
    help_str = """
    This script is used by Andromeda to transform custom app type1 inventory csv into Andromeda Inventory
    Example:
        python3 custom_app_type1_transformer.py --app_name=billing --inventory_file=billing_inventory.csv

    There is a registry of the application name to choose the transformer class if multiple present in
    a single file. Eg.
    app_to_transformer_map = {
        'custom_app_sample': CustomAppSampleTransformer,
    }
    """

    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawTextHelpFormatter,
        description=(help_str)
    )

    parser.add_argument(
        '--app_name', '-n', default='custom_app_sample',
        help='application name. Preffered to use the name used in custom application in Andromeda')

    parser.add_argument(
        '--inventory_file', '-i',
        help='inventory file name. Eg. inventory.csv')

    parser.add_argument(
        '--output_dir', '-o',
        help='output dir. Ouput is written to {output_dir}/{app_name}-{timestamp}.json',
        default='/tmp/customapp_export/')

    return parser.parse_args()


def main() -> None:
    """Main entry point for the script."""
    args = parse_arguments()
    setup_logging()

    app_to_transformer_map = {
        'custom_app_sample': CustomAppSampleTransformer,
    }

    try:
        # Find the transformer class based on the app name
        transformer_class = app_to_transformer_map.get(
            args.app_name.strip(), CustomAppSampleTransformer)

        # Create the transformer instance
        transformer = transformer_class(
            app_name=args.app_name.strip(),
            inventory_file=args.inventory_file.strip(),
            output_dir=args.output_dir.strip())

        # Transform and export the inventory
        transformer.transform_and_export()
        logger.info("Transformation completed successfully")

    except Exception as e:
        logger.error("Transformation failed: {%s}", e)
        logger.error("Stack trace: %s", traceback.format_exc())
        raise


if __name__ == '__main__':
    main()
